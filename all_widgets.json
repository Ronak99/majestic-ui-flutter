[
  {
    "name": "star_rush_background",
    "label": "Star Rush Background",
    "description": "Beautiful package to elevate your app.",
    "files": [
      {
        "name": "star_rush_background.dart",
        "dir": "lib/majestic/ui",
        "content": "import 'dart:async';\nimport 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flutter/material.dart';\n\nclass StarRushBackground extends StatefulWidget {\n  /// speed must be in range: 0 to 1000\n  final double speed;\n  final double starSpeed;\n\n  const StarRushBackground({\n    super.key,\n    required this.speed,\n  }) : starSpeed = speed / 1000;\n\n  @override\n  State<StarRushBackground> createState() => _RushingStarsViewState();\n}\n\nclass _RushingStarsViewState extends State<StarRushBackground> {\n  Timer? timer;\n  List<Star> stars = [];\n  int numStars = 500;\n\n  @override\n  void initState() {\n    super.initState();\n\n    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {\n      final double height = MediaQuery.of(context).size.height;\n      final double width = MediaQuery.of(context).size.width;\n\n      while (stars.length < numStars) {\n        stars.add(\n          Star(\n            x: StarsUtils.range(0, width),\n            y: StarsUtils.range(0, height),\n            canvasHeight: height,\n            canvasWidth: width,\n          ),\n        );\n      }\n\n      // refresh rate of 60\n      const duration = Duration(milliseconds: 1000 ~/ 60);\n      timer = Timer.periodic(duration, (timer) {\n        _logic(height, width);\n      });\n    });\n  }\n\n  _logic(height, width) {\n    stars = stars.where((star) {\n      star.update(widget.starSpeed);\n      return star.isActive();\n    }).toList();\n\n    while (stars.length < numStars) {\n      stars.add(\n        Star(\n          x: StarsUtils.range(0, width),\n          y: StarsUtils.range(0, height),\n          canvasHeight: height,\n          canvasWidth: width,\n        ),\n      );\n    }\n\n    if (mounted) {\n      setState(() {});\n    }\n  }\n\n  @override\n  void dispose() {\n    timer?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: StarPainter(stars: stars),\n    );\n  }\n}\n\nclass Star {\n  Offset pos, prevPos, vel;\n  double ang;\n  double canvasHeight;\n  double canvasWidth;\n  Color color;\n  double radius;\n\n  Star({\n    required double x,\n    required double y,\n    required this.canvasHeight,\n    required this.canvasWidth,\n  })  : color = StarsUtils.generateRandomColor(),\n        radius = StarsUtils.range(2, 6),\n        pos = Offset(x, y),\n        prevPos = Offset(x, y),\n        vel = Offset.zero,\n        ang = atan2(y - (canvasHeight / 2.5), x - (canvasWidth / 2));\n\n  bool isActive() =>\n      pos.dx >= 0 &&\n      pos.dx <= canvasWidth &&\n      pos.dy >= 0 &&\n      pos.dy <= canvasHeight;\n\n  void update(double acc) {\n    vel += Offset(cos(ang) * acc, sin(ang) * acc);\n    prevPos = pos;\n    pos += vel;\n  }\n\n  void draw(Canvas canvas) {\n    final alpha = lerpDouble(0, 255, vel.distance / 3)!;\n\n    final paint = Paint()\n      ..color =\n          alpha >= 0 && alpha <= 255 ? color.withOpacity(alpha / 255) : color\n      ..strokeWidth = radius\n      ..strokeCap = StrokeCap.round;\n    canvas.drawLine(pos, prevPos, paint);\n  }\n}\n\nclass StarsUtils {\n  static final random = Random();\n\n  static bool getRandomBool() => random.nextBool();\n\n  static Color generateRandomColor() {\n    int red = random.nextInt(156) + 100;\n    int green = random.nextInt(156) + 100;\n    int blue = random.nextInt(156) + 100;\n\n    return Color.fromARGB(\n      255,\n      red,\n      green,\n      blue,\n    );\n  }\n\n  static double range(double min, double max) =>\n      random.nextDouble() * (max - min) + min;\n}\n\nclass StarPainter extends CustomPainter {\n  List<Star> stars;\n  StarPainter({required this.stars});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    // draw the stars\n    for (var s in stars) {\n      s.draw(canvas);\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return true;\n  }\n}\n"
      }
    ],
    "dependencies": [],
    "type": "ui",
    "author": "Ronak99",
    "github": "https://github.com/Ronak99",
    "demo": "import 'package:flutter/material.dart';\nimport 'package:star_rush_background/star_rush_background.dart';\n\nclass StarRushBackgroundDemo extends StatelessWidget {\n  const StarRushBackgroundDemo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: StarRushBackground(\n        speed: 35,\n      ),\n    );\n  }\n}\n"
  },
  {
    "name": "avatar",
    "label": "Avatar",
    "description": "Beautiful avatar.",
    "files": [
      {
        "name": "majestic_avatar.dart",
        "dir": "majestic/ui",
        "content": "library majestic_avatar;\n\nimport 'dart:math';\n\nimport 'package:cached_network_image/cached_network_image.dart';\nimport 'package:flutter/material.dart';\n\nColor _generateRandomColor() {\n  return Color.fromARGB(\n    255,\n    Random().nextInt(256),\n    Random().nextInt(256),\n    Random().nextInt(256),\n  );\n}\n\n/*\nRULES:\n\n[src] can be\n1. NULL - If it is null, then show background text with random color.\n2. Empty - If it is empty, then show background text with random color.\n3. Network URL - Fetch data from network image.\n4. Asset image - Fetch data using Image.asset.\n\n[isRound vs radius]\n1. isRound and radius, either of those two params are required, not both.\n\n[placeholder]\n\n*/\nclass MajesticAvatar extends StatefulWidget {\n  final String? src;\n  final double radius;\n  final String? text;\n  final TextStyle? textStyle;\n  final Color? background;\n  final double? height;\n  final double? width;\n  final BoxFit fit;\n  final bool isRound;\n  final bool useOldImageOnUrlChange;\n\n  const MajesticAvatar(\n    this.src, {\n    super.key,\n    this.isRound = false,\n    this.radius = 0,\n    this.height,\n    this.width,\n    this.fit = BoxFit.cover,\n    this.useOldImageOnUrlChange = false,\n    this.text,\n    this.textStyle,\n    this.background,\n  });\n\n  @override\n  State<MajesticAvatar> createState() => _CachedImageState();\n}\n\nclass _CachedImageState extends State<MajesticAvatar> {\n  Color? _color;\n\n  @override\n  void initState() {\n    super.initState();\n    _color = widget.background ?? _generateRandomColor();\n  }\n\n  Widget _baseBackground(String? text) {\n    return Container(\n      decoration: BoxDecoration(\n        shape: widget.isRound ? BoxShape.circle : BoxShape.rectangle,\n        color: _color,\n      ),\n      height: widget.height,\n      width: widget.width,\n      alignment: Alignment.center,\n      child: text != null\n          ? LayoutBuilder(\n              builder: (context, constraints) {\n                double fontSize =\n                    min(constraints.maxWidth, constraints.maxHeight) * 0.5;\n                return Text(\n                  text[0].toUpperCase(),\n                  style: TextStyle(\n                    fontSize: fontSize,\n                    fontWeight: FontWeight.w500,\n                    color: _color!.computeLuminance() > .5\n                        ? Colors.black\n                        : Colors.white,\n                  ),\n                );\n              },\n            )\n          : const SizedBox.shrink(),\n    );\n  }\n\n  Widget _getChild() {\n    if (widget.src == null) {\n      return _baseBackground(widget.text);\n    }\n    return CachedNetworkImage(\n      imageUrl: widget.src!,\n      fit: widget.fit,\n      useOldImageOnUrlChange: widget.useOldImageOnUrlChange,\n      placeholder: (context, url) => _baseBackground(widget.text),\n      errorWidget: (context, url, error) {\n        print(error);\n        return Container(\n          height: widget.height,\n          width: widget.width,\n          color: Colors.black,\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      height: widget.height,\n      width: widget.width,\n      child: ClipRRect(\n        borderRadius: widget.isRound\n            ? BorderRadius.circular(300)\n            : BorderRadius.circular(widget.radius),\n        child: _getChild(),\n      ),\n    );\n  }\n}\n"
      }
    ],
    "dependencies": ["cached_network_image"],
    "type": "ui",
    "author": "Ronak99",
    "github": "https://github.com/Ronak99",
    "demo": "import 'package:avatar/majestic_avatar.dart';\nimport 'package:flutter/material.dart';\n\nclass MajesticAvatarDemo extends StatelessWidget {\n  const MajesticAvatarDemo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            MajesticAvatar(\n              \"https://picsum.photos/50\",\n              isRound: true,\n              height: 50,\n              width: 50,\n              radius: 2,\n              text: \"Ronak\",\n            ),\n            Text(\"ronak\"),\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
  },
  {
    "name": "animated_button",
    "label": "Animated Button",
    "description": "Beautiful animated button.",
    "files": [
      {
        "name": "animated_button.dart",
        "dir": "majestic/ui",
        "content": "import 'package:flutter/material.dart';\nimport 'package:mesh_gradient/mesh_gradient.dart';\n\nclass AnimationOptions {\n  final double frequency;\n  final double amplitude;\n  final double speed;\n  final double grain;\n\n  const AnimationOptions({\n    this.frequency = 5,\n    this.amplitude = 30,\n    this.speed = 2,\n    this.grain = 0,\n  })  : assert(grain >= 0 && grain <= 1),\n        assert(speed >= 0.01 && speed <= 15);\n\n  factory AnimationOptions.subtle() {\n    return const AnimationOptions(\n      frequency: 3,\n      amplitude: 15,\n      speed: 1,\n      grain: 0.2,\n    );\n  }\n\n  // Dramatic animation preset\n  factory AnimationOptions.dramatic() {\n    return const AnimationOptions(\n      frequency: 8,\n      amplitude: 45,\n      speed: 4,\n      grain: 0.5,\n    );\n  }\n}\n\nclass MajesticAnimatedButton extends StatelessWidget {\n  final dynamic child;\n  final VoidCallback onPressed;\n  final EdgeInsets padding;\n  final BorderRadiusGeometry borderRadius;\n  final List<Color>? colors;\n  final AnimationOptions options;\n\n  const MajesticAnimatedButton({\n    super.key,\n    required this.child,\n    this.padding = const EdgeInsets.symmetric(horizontal: 18, vertical: 6),\n    this.borderRadius = const BorderRadius.all(Radius.circular(100)),\n    this.colors,\n    this.options = const AnimationOptions(),\n    required this.onPressed,\n  }) : assert(child is Widget || child is String);\n\n  @override\n  Widget build(BuildContext context) {\n    return FittedBox(\n      child: GestureDetector(\n        onTap: onPressed,\n        child: ClipRRect(\n          borderRadius: borderRadius,\n          child: AnimatedMeshGradient(\n            colors: colors != null && colors!.isNotEmpty\n                ? colors!\n                : const [\n                    Colors.pink,\n                    Colors.blueAccent,\n                    Color.fromARGB(255, 199, 6, 6),\n                    Colors.purple\n                  ],\n            options: AnimatedMeshGradientOptions(\n              speed: options.speed,\n              amplitude: options.amplitude,\n              frequency: options.frequency,\n              grain: options.grain,\n            ),\n            child: Container(\n              padding: padding,\n              alignment: Alignment.center,\n              child: child is String\n                  ? Text(\n                      child,\n                      style: const TextStyle(\n                        color: Colors.white,\n                        fontWeight: FontWeight.w600,\n                        fontSize: 15,\n                      ),\n                    )\n                  : child,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n"
      }
    ],
    "dependencies": ["mesh_gradient"],
    "type": "ui",
    "author": "Ronak99",
    "github": "https://github.com/Ronak99",
    "demo": "import 'package:animated_button/animated_button.dart';\nimport 'package:flutter/material.dart';\n\nclass MajesticAnimatedButtonDemo extends StatelessWidget {\n  const MajesticAnimatedButtonDemo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: MajesticAnimatedButton(\n          child: const Icon(\n            Icons.person,\n            color: Colors.white,\n          ),\n          onPressed: () {},\n        ),\n      ),\n    );\n  }\n}\n"
  },
  {
    "name": "user_feed",
    "label": "User Feed",
    "description": "Fully functional tiktok/instagram like user feed, with inbuilt advertisement support and pagination.",
    "files": [
      {
        "name": "user_feed.dart",
        "dir": "majestic/ui/user_feed",
        "content": "import 'dart:math' as math;\n\nimport 'package:custom_refresh_indicator/custom_refresh_indicator.dart';\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:video_player/video_player.dart';\nimport 'package:visibility_detector/visibility_detector.dart';\n\n// local imports\nimport 'models/user_feed_post.dart';\nimport 'provider/user_feed_provider.dart';\n\nclass UserFeed extends StatefulWidget {\n  const UserFeed({super.key});\n\n  @override\n  State<UserFeed> createState() => _UserFeedState();\n}\n\nclass _UserFeedState extends State<UserFeed> {\n  @override\n  void initState() {\n    super.initState();\n\n    // ideally this call should be made at a place where initState is not called often or only called once the app is launched.\n    context.read<UserFeedProvider>().initialize();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final provider = context.watch<UserFeedProvider>();\n\n    if (provider.isInitializingFeed) {\n      return const Center(\n        child: Text(\"Initializing feed...\"),\n      );\n    }\n\n    return CustomMaterialIndicator(\n      backgroundColor: Colors.black,\n      onRefresh: provider.refreshFeed,\n      indicatorBuilder: (context, controller) {\n        return Padding(\n          padding: const EdgeInsets.all(6.0),\n          child: CircularProgressIndicator(\n            color: Colors.white,\n            value: controller.state.isLoading\n                ? null\n                : math.min(controller.value, 1.0),\n          ),\n        );\n      },\n      child: Scaffold(\n        backgroundColor: Colors.black26,\n        body: provider.feed.isEmpty\n            ? const DescriptiveText(\"Your feed is empty.\")\n            : PageView.builder(\n                controller: provider.feedController,\n                scrollDirection: Axis.vertical,\n                itemCount: provider.feed.length,\n                onPageChanged: provider.onVideoChanged,\n                itemBuilder: (context, index) {\n                  final post = provider.feed[index];\n\n                  if (post is VideoFeedPost) {\n                    return VideoPlayerWidget(\n                      controller: provider.getController(index),\n                      index: index,\n                      videoPost: post,\n                    );\n                  }\n                  // else if (post is AdvertisementFeedPost) {\n                  //   return AdvertisementView(adPost: post);\n                  // }\n\n                  return const SizedBox.shrink(); // Fallback\n                },\n              ),\n      ),\n    );\n  }\n}\n\nclass VideoPlayerWidget extends StatelessWidget {\n  final VideoPlayerController? controller;\n  final int index;\n  final VideoFeedPost videoPost;\n\n  const VideoPlayerWidget({\n    super.key,\n    required this.controller,\n    required this.index,\n    required this.videoPost,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final provider = context.read<UserFeedProvider>();\n\n    if (controller == null || !controller!.value.isInitialized) {\n      return const DescriptiveText('Loading...');\n    }\n\n    return VisibilityDetector(\n      key: Key('video-$index'),\n      onVisibilityChanged: (visibilityInfo) {\n        provider.handleVisibilityChanged(index, visibilityInfo.visibleFraction);\n      },\n      child: Stack(\n        fit: StackFit.expand,\n        children: [\n          _buildVideoPlayer(context),\n          // _buildAudioControl(),\n          // ..._buildBottomContent(),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildVideoPlayer(BuildContext context) {\n    return GestureDetector(\n      behavior: HitTestBehavior.translucent,\n      onTap: () => context.read<UserFeedProvider>().togglePlayPause(index),\n      child: LayoutBuilder(\n        builder: (_, constraints) {\n          return Stack(\n            fit: StackFit.expand,\n            children: [\n              _buildVideoDisplay(constraints),\n              VideoPlayPauseOverlay(controller: controller!),\n            ],\n          );\n        },\n      ),\n    );\n  }\n\n  Widget _buildVideoDisplay(BoxConstraints constraints) {\n    if (controller!.value.aspectRatio < 1) {\n      return SizedBox(\n        width: controller!.value.size.width,\n        height: constraints.maxHeight,\n        child: VideoPlayer(controller!),\n      );\n    }\n    return Center(\n      child: AspectRatio(\n        aspectRatio: controller!.value.aspectRatio,\n        child: VideoPlayer(controller!),\n      ),\n    );\n  }\n\n  // Widget _buildAudioControl() {\n  //   return Align(\n  //     alignment: Alignment.topRight,\n  //     child: Padding(\n  //       padding: const EdgeInsets.only(right: 15, top: 15),\n  //       child: AudioControlButton(videoPlayerController: controller!),\n  //     ),\n  //   );\n  // }\n\n  // List<Widget> _buildBottomContent() {\n  //   return [\n  //     Align(\n  //       alignment: Alignment.bottomLeft,\n  //       child: FeedBottomLeftView(\n  //         authorId: videoPost.createdBy!,\n  //         caption: videoPost.title,\n  //       ),\n  //     ),\n  //     Align(\n  //       alignment: Alignment.bottomRight,\n  //       child: FeedBottomRightView(\n  //         commentCount: videoPost.commentCount,\n  //         likeCount: videoPost.likeCount,\n  //         postId: videoPost.id,\n  //         viewCount: videoPost.views,\n  //         authorId: videoPost.createdBy!,\n  //       ),\n  //     ),\n  //   ];\n  // }\n}\n\nclass VideoPlayPauseOverlay extends StatefulWidget {\n  final VideoPlayerController controller;\n  const VideoPlayPauseOverlay({super.key, required this.controller});\n\n  @override\n  State<VideoPlayPauseOverlay> createState() => _VideoPlayPauseOverlayState();\n}\n\nclass _VideoPlayPauseOverlayState extends State<VideoPlayPauseOverlay> {\n  bool showPlayArrow = true;\n\n  @override\n  void initState() {\n    super.initState();\n\n    widget.controller.addListener(() {\n      if (mounted && showPlayArrow != !widget.controller.value.isPlaying) {\n        showPlayArrow = !widget.controller.value.isPlaying;\n        setState(() {});\n      }\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: AnimatedOpacity(\n        duration: const Duration(milliseconds: 200),\n        opacity: showPlayArrow ? 1 : 0,\n        child: Container(\n          decoration: const BoxDecoration(\n            color: Colors.black26,\n            shape: BoxShape.circle,\n          ),\n          padding: const EdgeInsets.all(15),\n          child: const Icon(\n            Icons.play_arrow_rounded,\n            size: 50,\n            color: Colors.white,\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n// class AdvertisementView extends StatelessWidget {\n//   final AdvertisementFeedPost adPost;\n\n//   const AdvertisementView({super.key, required this.adPost});\n\n//   @override\n//   Widget build(BuildContext context) {\n//     return Center(\n//       child: GestureDetector(\n//         onTap: () => Utils.navigateTo(WebviewContainer(advertisement: adPost)),\n//         child: Container(\n//           color: Colors.black,\n//           child: Stack(\n//             children: [\n//               Container(\n//                 decoration: BoxDecoration(\n//                   image: DecorationImage(\n//                     image: CachedNetworkImageProvider(\n//                       adPost.backgroundImage!,\n//                     ),\n//                     fit: BoxFit.cover,\n//                   ),\n//                 ),\n//               ),\n//               // child: CachedImage(adPost.backgroundImage),\n//               Padding(\n//                 padding: const EdgeInsets.symmetric(horizontal: 16),\n//                 child: Column(\n//                   mainAxisAlignment: MainAxisAlignment.end,\n//                   children: [\n//                     Align(\n//                       alignment: Alignment.bottomLeft,\n//                       child: Container(\n//                         decoration: BoxDecoration(\n//                           color: Colors.amber[800],\n//                           borderRadius: BorderRadius.circular(25),\n//                         ),\n//                         padding: const EdgeInsets.symmetric(\n//                           horizontal: 30,\n//                           vertical: 10,\n//                         ),\n//                         child: const Text(\n//                           'Sponsored Ad',\n//                           style: TextStyle(\n//                             fontWeight: FontWeight.w600,\n//                             color: Colors.white,\n//                             fontSize: 14,\n//                           ),\n//                         ),\n//                       ),\n//                     ),\n//                     const SizedBox(height: 16),\n//                     Container(\n//                       width: double.infinity,\n//                       decoration: BoxDecoration(\n//                         color: Colors.black38,\n//                         borderRadius: BorderRadius.circular(25),\n//                       ),\n//                       padding: const EdgeInsets.symmetric(\n//                         horizontal: 22,\n//                         vertical: 12,\n//                       ),\n//                       alignment: Alignment.center,\n//                       child: const Text(\n//                         'View Official Site ',\n//                         style: TextStyle(\n//                           fontWeight: FontWeight.w600,\n//                           color: Colors.white,\n//                           fontSize: 14,\n//                         ),\n//                       ),\n//                     ),\n//                     const SizedBox(height: 16),\n//                   ],\n//                 ),\n//               ),\n//             ],\n//           ),\n//         ),\n//       ),\n//     );\n//   }\n// }\n\nclass DescriptiveText extends StatelessWidget {\n  final String text;\n\n  const DescriptiveText(this.text, {super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\n        text,\n        style: TextStyle(\n          color: Colors.white.withOpacity(0.5),\n          fontWeight: FontWeight.w600,\n          fontSize: 15,\n        ),\n      ),\n    );\n  }\n}\n"
      },
      {
        "name": "user_feed_provider.dart",
        "dir": "majestic/ui/user_feed/provider",
        "content": "import 'package:flutter/material.dart';\nimport 'package:flutter_cache_manager/flutter_cache_manager.dart';\nimport 'package:video_player/video_player.dart';\nimport 'dart:collection';\n\nimport '../models/user_feed_post.dart';\nimport '../services/ad_service.dart';\nimport '../services/video_control_service.dart';\nimport '../services/video_service.dart';\n\nclass UserFeedProvider extends ChangeNotifier {\n  // services\n  final VideoService _videoService = VideoService();\n  final AdService _adService = AdService();\n\n  // state\n\n  final List<UserFeedPost> _feed = [];\n  final Map<int, VideoPlayerController> _controllerCache = {};\n  final Queue<int> _preloadQueue = Queue();\n  final PageController feedController = PageController();\n  final PageStorageBucket feedBucket = PageStorageBucket();\n\n  final List<AdvertisementFeedPost> _activeAds = [];\n\n  VideoFeedPost? _lastVideoPost;\n  int _currentAdIndex = 0;\n  bool _isInitializingFeed = true;\n  int _currentIndex = 0;\n\n  static const int BATCH_SIZE = 20;\n  static const int AD_INTERVAL = 1;\n  static const int FETCH_THRESHOLD = 15;\n  static const int MAX_CACHED_CONTROLLERS = 6;\n  static const int PRELOAD_COUNT = 6;\n\n  // Getters\n  List<UserFeedPost> get feed => UnmodifiableListView(_feed);\n  bool get isInitializingFeed => _isInitializingFeed;\n  int get currentIndex => _currentIndex;\n  VideoPlayerController? getController(int index) {\n    final post = _feed[index];\n    return (post is VideoFeedPost) ? _controllerCache[index] : null;\n  }\n\n  bool get isEmpty => _feed.isEmpty;\n\n  Future<void> initialize() async {\n    await _fetchActiveAds();\n    await _loadInitialVideos();\n  }\n\n  Future<void> _fetchActiveAds() async {\n    // try {\n    //   final querySnapshot = await _adService.queryAllActiveAds();\n\n    //   _activeAds = querySnapshot.docs.map((doc) => doc.data()).toList();\n    // } catch (e) {\n    //   print('Error fetching ads: $e');\n    //   _activeAds = [];\n    // }\n  }\n\n  AdvertisementFeedPost? _getNextAd() {\n    if (_activeAds.isEmpty) return null;\n    final ad = _activeAds[_currentAdIndex];\n    _currentAdIndex = (_currentAdIndex + 1) % _activeAds.length;\n    return ad;\n  }\n\n  void _insertAds(List<VideoFeedPost> videos) {\n    int feedIndex = _feed.length;\n    for (var video in videos) {\n      _feed.add(video);\n      // Insert ad after every AD_INTERVAL videos\n      if ((feedIndex + 1) % AD_INTERVAL == 0) {\n        final ad = _getNextAd();\n        if (ad != null) {\n          _feed.add(ad);\n        }\n      }\n      feedIndex++;\n    }\n  }\n\n  Future<void> _loadInitialVideos() async {\n    try {\n      var userFeedQuery =\n          await _videoService.fetchUserFeedQuery(limit: BATCH_SIZE);\n\n      if (userFeedQuery.isNotEmpty) {\n        _lastVideoPost = userFeedQuery.last;\n        final videos = userFeedQuery;\n        _insertAds(videos);\n\n        await _initializeCurrentController();\n      }\n    } catch (e) {\n      print('Error loading initial videos: $e');\n    }\n\n    _isInitializingFeed = false;\n    notifyListeners();\n  }\n\n  Future<void> loadMoreVideos() async {\n    if (_isInitializingFeed || _lastVideoPost == null) return;\n    try {\n      var userFeedQuery = await _videoService.fetchUserFeedQuery(\n        limit: BATCH_SIZE,\n        after: _lastVideoPost,\n      );\n\n      if (userFeedQuery.isNotEmpty) {\n        _lastVideoPost = userFeedQuery.last;\n        final videos = userFeedQuery;\n        _insertAds(videos);\n      }\n    } catch (e) {\n      print('Error loading more videos: $e');\n    }\n  }\n\n  void jumpToTop() {\n    feedController.jumpToPage(0);\n  }\n\n  Future<void> refreshFeed() async {\n    try {\n      _isInitializingFeed = true;\n      notifyListeners();\n\n      // Refresh ads first\n      await _fetchActiveAds();\n      _currentAdIndex = 0;\n\n      // Clear existing data\n      _feed.clear();\n      _controllerCache.clear();\n      _currentIndex = 0;\n      _lastVideoPost = null;\n\n      // Get fresh videos\n      var userFeedQuery = await _videoService.fetchUserFeedQuery(\n        limit: BATCH_SIZE,\n        after: _lastVideoPost,\n      );\n\n      if (userFeedQuery.isNotEmpty) {\n        _lastVideoPost = userFeedQuery.last;\n        final videos = userFeedQuery;\n        _insertAds(videos);\n      }\n\n      // Initialize first video if it exists\n      if (_feed.isNotEmpty) {\n        await _initializeCurrentController();\n      }\n\n      _isInitializingFeed = false;\n      notifyListeners();\n    } catch (e) {\n      print('Error refreshing feed: $e');\n      _isInitializingFeed = false;\n      notifyListeners();\n    }\n  }\n\n  Future<void> _initializeCurrentController() async {\n    await _initializeController(_currentIndex);\n    _preloadNextVideos(_currentIndex);\n  }\n\n  Future<void> _initializeController(int index) async {\n    final post = _feed[index];\n    if (post is! VideoFeedPost) return;\n\n    if (_controllerCache.containsKey(index)) return;\n\n    if (_controllerCache.length >= MAX_CACHED_CONTROLLERS) {\n      _cleanupControllers();\n    }\n\n    try {\n      final controller =\n          await CachedVideoControllerService(DefaultCacheManager())\n              .getControllerForVideo(post.videoUrl!);\n      _controllerCache[index] = controller;\n\n      await controller.initialize();\n      controller.setLooping(true);\n\n      notifyListeners();\n    } catch (e) {\n      print('Error initializing controller for index $index: $e');\n      _controllerCache.remove(index);\n    }\n  }\n\n  void _cleanupControllers() {\n    final keysToRemove = _controllerCache.keys\n        .where((key) => (key - _currentIndex).abs() > 1)\n        .toList()\n      ..sort((a, b) => (a - _currentIndex).abs() - (b - _currentIndex).abs());\n\n    if (keysToRemove.isNotEmpty) {\n      _disposeController(keysToRemove.first);\n    }\n  }\n\n  Future<void> _disposeController(int index) async {\n    final controller = _controllerCache[index];\n    if (controller != null) {\n      await controller.dispose();\n      _controllerCache.remove(index);\n    }\n  }\n\n  void _preloadNextVideos(int currentIndex) {\n    _preloadQueue.clear();\n\n    for (int offset = 1; offset < PRELOAD_COUNT / 2; offset++) {\n      if (currentIndex + offset < _feed.length) {\n        _preloadQueue.add(currentIndex + offset);\n      }\n      if (currentIndex - offset >= 0) {\n        _preloadQueue.add(currentIndex - offset);\n      }\n    }\n\n    _processPreloadQueue();\n  }\n\n  Future<void> _processPreloadQueue() async {\n    while (_preloadQueue.isNotEmpty) {\n      final index = _preloadQueue.removeFirst();\n      await _initializeController(index);\n    }\n  }\n\n  void onVideoChanged(int index) {\n    if (index == _currentIndex) return;\n\n    if (index >= _feed.length - FETCH_THRESHOLD) {\n      loadMoreVideos();\n    }\n\n    // Only pause/play if it's a video post\n    if (_feed[_currentIndex] is VideoFeedPost) {\n      _controllerCache[_currentIndex]?.pause();\n    }\n\n    _currentIndex = index;\n\n    if (_feed[_currentIndex] is VideoFeedPost) {\n      _controllerCache[_currentIndex]?.play();\n    }\n\n    _preloadNextVideos(_currentIndex);\n\n    notifyListeners();\n  }\n\n  void togglePlayPause(int index) {\n    final controller = _controllerCache[index];\n    if (controller != null) {\n      if (controller.value.isPlaying) {\n        controller.pause();\n      } else {\n        controller.play();\n      }\n      notifyListeners();\n    }\n  }\n\n  void handleVisibilityChanged(int index, double visibilityFraction) {\n    final controller = _controllerCache[index];\n    if (controller != null) {\n      if (visibilityFraction > 0.8) {\n        controller.play();\n      } else {\n        controller.pause();\n      }\n    }\n  }\n\n  @override\n  void dispose() {\n    for (var controller in _controllerCache.values) {\n      controller.dispose();\n    }\n    _controllerCache.clear();\n    super.dispose();\n  }\n}\n"
      },
      {
        "name": "user_feed_post.dart",
        "dir": "majestic/ui/user_feed/models",
        "content": "abstract class UserFeedPost {\n  late String? id;\n  late bool isVideoPost;\n}\n\nclass VideoFeedPost extends UserFeedPost {\n  String? title;\n  String description;\n  String? thumbnailUrl;\n  String? videoUrl;\n  String? createdBy;\n  int? createdOn;\n  int? updatedOn;\n  int? likeCount;\n  int? commentCount;\n  VideoFeedPost({\n    this.title,\n    this.description = '',\n    this.thumbnailUrl,\n    this.videoUrl,\n    this.createdBy,\n    this.createdOn,\n    this.updatedOn,\n    this.likeCount,\n    this.commentCount,\n  });\n}\n\nclass AdvertisementFeedPost extends UserFeedPost {}\n"
      },
      {
        "name": "data.dart",
        "dir": "majestic/ui/user_feed/data",
        "content": "import '../models/user_feed_post.dart';\n\nList<VideoFeedPost> userFeed = [\n  VideoFeedPost(\n    title: \"Girl with red hair\",\n    videoUrl:\n        \"https://videos.pexels.com/video-files/2795405/2795405-uhd_1440_2560_25fps.mp4\",\n  ),\n  VideoFeedPost(\n    title: \"Happy Old Woman.\",\n    videoUrl:\n        \"https://videos.pexels.com/video-files/4058073/4058073-uhd_1440_2732_25fps.mp4\",\n  ),\n];\n"
      },
      {
        "name": "ad_service.dart",
        "dir": "majestic/ui/user_feed/services",
        "content": "class AdService {}\n"
      },
      {
        "name": "video_service.dart",
        "dir": "majestic/ui/user_feed/services",
        "content": "import '../data/data.dart';\nimport '../models/user_feed_post.dart';\n\nclass VideoService {\n  Future<List<VideoFeedPost>> fetchUserFeedQuery({\n    required int limit,\n    VideoFeedPost? after,\n  }) async {\n    await Future.delayed(const Duration(seconds: 2));\n    return userFeed;\n  }\n}\n"
      },
      {
        "name": "video_control_service.dart",
        "dir": "majestic/ui/user_feed/services",
        "content": "import 'dart:async';\n\nimport 'package:flutter_cache_manager/flutter_cache_manager.dart';\nimport 'package:video_player/video_player.dart';\n\nabstract class VideoControlService {\n  Future<VideoPlayerController> getControllerForVideo(String videoUrl);\n}\n\nclass CachedVideoControllerService extends VideoControlService {\n  final BaseCacheManager _cacheManager;\n\n  CachedVideoControllerService(this._cacheManager);\n\n  @override\n  Future<VideoPlayerController> getControllerForVideo(String videoUrl,\n      {bool mixWithOthers = false}) async {\n    final fileInfo = await _cacheManager.getFileFromCache(videoUrl);\n\n    if (fileInfo == null) {\n      print('[VideoControllerService]: No video in cache');\n\n      print('[VideoControllerService]: Saving video to cache');\n      unawaited(_cacheManager.downloadFile(videoUrl));\n\n      return VideoPlayerController.networkUrl(Uri.parse(videoUrl),\n          videoPlayerOptions: VideoPlayerOptions(mixWithOthers: mixWithOthers));\n    } else {\n      print('[VideoControllerService]: Loading video from cache');\n      return VideoPlayerController.file(fileInfo.file,\n          videoPlayerOptions: VideoPlayerOptions(mixWithOthers: mixWithOthers));\n    }\n  }\n}\n"
      }
    ],
    "dependencies": [
      "cached_network_image",
      "custom_refresh_indicator",
      "flutter_cache_manager",
      "provider",
      "video_player",
      "visibility_detector"
    ],
    "type": "ui",
    "author": "Ronak99",
    "github": "https://github.com/Ronak99",
    "demo": "import 'package:flutter/material.dart';\nimport 'package:user_feed/user_feed.dart';\n\nclass UserFeedDemo extends StatelessWidget {\n  const UserFeedDemo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: UserFeed(),\n    );\n  }\n}\n"
  }
]
