{
  "name": "star_rush_background",
  "label": "Star Rush Background",
  "description": "Beautiful package to elevate your app.",
  "dependencies": [],
  "demo": "import 'package:flutter/material.dart';\n\nimport 'majestic/ui/star_rush_background.dart';\n\nclass StarRushBackgroundDemo extends StatelessWidget {\n  const StarRushBackgroundDemo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      backgroundColor: Colors.black,\n      body: Stack(\n        children: [\n          StarRushBackground(\n            speed: 750,\n            maxRadius: 2,\n            minRadius: 1,\n            colors: [\n              Colors.blue[100]!,\n              Colors.blue[300]!,\n              Colors.red[200]!,\n              Colors.white,\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
  "files": [
    {
      "name": "star_rush_background.dart",
      "dir": "lib/majestic/ui",
      "content": "import 'dart:async';\nimport 'dart:math';\nimport 'dart:ui';\n\nimport 'package:flutter/material.dart';\n\nclass StarRushBackground extends StatefulWidget {\n  /// speed must be in range: 0 to 1000\n  final double speed;\n  final List<Color> colors;\n  final double starSpeed;\n  final double minRadius;\n  final double maxRadius;\n\n  const StarRushBackground({\n    super.key,\n    required this.speed,\n    this.minRadius = 2,\n    this.maxRadius = 6,\n    this.colors = const [],\n  }) : starSpeed = speed / 1000;\n\n  @override\n  State<StarRushBackground> createState() => _StarRushBackgroundState();\n}\n\nclass _StarRushBackgroundState extends State<StarRushBackground> {\n  Timer? timer;\n  List<Star> stars = [];\n  int numStars = 500;\n\n  @override\n  void initState() {\n    super.initState();\n\n    WidgetsBinding.instance.addPostFrameCallback((timeStamp) {\n      final double height = MediaQuery.of(context).size.height;\n      final double width = MediaQuery.of(context).size.width;\n\n      while (stars.length < numStars) {\n        addStar(height: height, width: width);\n      }\n\n      // refresh rate of 60\n      const duration = Duration(milliseconds: 1000 ~/ 60);\n      timer = Timer.periodic(duration, (timer) {\n        _logic(height, width);\n      });\n    });\n  }\n\n  void addStar({required double height, required double width}) {\n    stars.add(\n      Star(\n        x: StarsUtils.range(0, width),\n        y: StarsUtils.range(0, height),\n        canvasHeight: height,\n        canvasWidth: width,\n        radius: StarsUtils.range(widget.minRadius, widget.maxRadius),\n        color: widget.colors.isEmpty\n            ? StarsUtils.generateRandomColor()\n            : widget.colors[StarsUtils.rangeInt(widget.colors.length - 1)],\n      ),\n    );\n  }\n\n  _logic(height, width) {\n    stars = stars.where((star) {\n      star.update(widget.starSpeed);\n      return star.isActive();\n    }).toList();\n\n    while (stars.length < numStars) {\n      addStar(height: height, width: width);\n    }\n\n    if (mounted) {\n      setState(() {});\n    }\n  }\n\n  @override\n  void dispose() {\n    timer?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return CustomPaint(\n      painter: StarPainter(stars: stars),\n    );\n  }\n}\n\nclass Star {\n  Offset pos, prevPos, vel;\n  double ang;\n  double canvasHeight;\n  double canvasWidth;\n  Color color;\n  double radius;\n\n  Star({\n    required double x,\n    required double y,\n    required this.canvasHeight,\n    required this.canvasWidth,\n    required this.radius,\n    required this.color,\n  })  : pos = Offset(x, y),\n        prevPos = Offset(x, y),\n        vel = Offset.zero,\n        ang = atan2(y - (canvasHeight / 2.5), x - (canvasWidth / 2));\n\n  bool isActive() =>\n      pos.dx >= 0 &&\n      pos.dx <= canvasWidth &&\n      pos.dy >= 0 &&\n      pos.dy <= canvasHeight;\n\n  void update(double acc) {\n    vel += Offset(cos(ang) * acc, sin(ang) * acc);\n    prevPos = pos;\n    pos += vel;\n  }\n\n  void draw(Canvas canvas) {\n    final alpha = lerpDouble(0, 255, vel.distance / 3)!;\n\n    final paint = Paint()\n      ..color =\n          alpha >= 0 && alpha <= 255 ? color.withOpacity(alpha / 255) : color\n      ..strokeWidth = radius\n      ..strokeCap = StrokeCap.round;\n    canvas.drawLine(pos, prevPos, paint);\n  }\n}\n\nclass StarsUtils {\n  static final random = Random();\n\n  static Color generateRandomColor() {\n    int red = random.nextInt(156) + 100;\n    int green = random.nextInt(156) + 100;\n    int blue = random.nextInt(156) + 100;\n\n    return Color.fromARGB(\n      255,\n      red,\n      green,\n      blue,\n    );\n  }\n\n  static double range(double min, double max) =>\n      random.nextDouble() * (max - min) + min;\n\n  static int rangeInt(int max) => random.nextInt(max);\n}\n\nclass StarPainter extends CustomPainter {\n  List<Star> stars;\n  StarPainter({required this.stars});\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    // draw the stars\n    for (var s in stars) {\n      s.draw(canvas);\n    }\n  }\n\n  @override\n  bool shouldRepaint(covariant CustomPainter oldDelegate) {\n    return true;\n  }\n}\n"
    }
  ]
}