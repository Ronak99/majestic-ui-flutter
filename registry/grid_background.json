{
  "name": "grid_background",
  "label": "Grid Background",
  "description": "Beautiful animated grid background inspired by CRED.",
  "dependencies": [],
  "demo": "import 'majestic/ui/grid_background/grid_background.dart';\nimport 'package:flutter/material.dart';\n\nclass AnimatedGridBackgroundDemo extends StatelessWidget {\n  const AnimatedGridBackgroundDemo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      backgroundColor: Colors.black,\n      // By default renders a white coloured grid, therefore looks best on a black background.\n      body: GridBackground(),\n    );\n  }\n}\n",
  "files": [
    {
      "name": "shimmer.dart",
      "dir": "lib/majestic/ui/grid_background",
      "content": "///\n/// A package provides an easy way to add shimmer effect to Flutter application\n/// The credit to this code goes to: hunghd.dev (https://pub.dev/publishers/hunghd.dev/packages)\n/// Package: https://pub.dev/packages/shimmer\n///\n\nlibrary shimmer;\n\nimport 'dart:developer';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/rendering.dart';\n\n///\n/// An enum defines all supported directions of shimmer effect\n///\n/// * [ShimmerDirection.ltr] left to right direction\n/// * [ShimmerDirection.rtl] right to left direction\n/// * [ShimmerDirection.ttb] top to bottom direction\n/// * [ShimmerDirection.btt] bottom to top direction\n///\nenum ShimmerDirection { ltr, rtl, ttb, btt }\n\n///\n/// A widget renders shimmer effect over [child] widget tree.\n///\n/// [child] defines an area that shimmer effect blends on. You can build [child]\n/// from whatever [Widget] you like but there're some notices in order to get\n/// exact expected effect and get better rendering performance:\n///\n/// * Use static [Widget] (which is an instance of [StatelessWidget]).\n/// * [Widget] should be a solid color element. Every colors you set on these\n/// [Widget]s will be overridden by colors of [gradient].\n/// * Shimmer effect only affects to opaque areas of [child], transparent areas\n/// still stays transparent.\n///\n/// [period] controls the speed of shimmer effect. The default value is 1500\n/// milliseconds.\n///\n/// [direction] controls the direction of shimmer effect. The default value\n/// is [ShimmerDirection.ltr].\n///\n/// [gradient] controls colors of shimmer effect.\n///\n/// [loop] the number of animation loop, set value of `0` to make animation run\n/// forever.\n///\n/// [enabled] controls if shimmer effect is active. When set to false the animation\n/// is paused\n///\n///\n/// ## Pro tips:\n///\n/// * [child] should be made of basic and simple [Widget]s, such as [Container],\n/// [Row] and [Column], to avoid side effect.\n///\n/// * use one [Shimmer] to wrap list of [Widget]s instead of a list of many [Shimmer]s\n///\n@immutable\nclass Shimmer extends StatefulWidget {\n  final Widget child;\n  final Duration period;\n  final ShimmerDirection direction;\n  final Gradient gradient;\n  final int loop;\n  final bool enabled;\n\n  const Shimmer({\n    super.key,\n    required this.child,\n    required this.gradient,\n    this.direction = ShimmerDirection.ltr,\n    this.period = const Duration(milliseconds: 1500),\n    this.loop = 0,\n    this.enabled = true,\n  });\n\n  ///\n  /// A convenient constructor provides an easy and convenient way to create a\n  /// [Shimmer] which [gradient] is [LinearGradient] made up of `baseColor` and\n  /// `highlightColor`.\n  ///\n  Shimmer.fromColors({\n    super.key,\n    required this.child,\n    required Color baseColor,\n    required Color highlightColor,\n    this.period = const Duration(milliseconds: 1500),\n    this.direction = ShimmerDirection.ltr,\n    this.loop = 0,\n    this.enabled = true,\n  }) : gradient = LinearGradient(\n            begin: Alignment.topLeft,\n            end: Alignment.centerRight,\n            colors: <Color>[\n              baseColor,\n              baseColor,\n              highlightColor,\n              baseColor,\n              baseColor\n            ],\n            stops: const <double>[\n              0.0,\n              0.35,\n              0.5,\n              0.65,\n              1.0\n            ]);\n\n  @override\n  _ShimmerState createState() => _ShimmerState();\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.add(DiagnosticsProperty<Gradient>('gradient', gradient,\n        defaultValue: null));\n    properties.add(EnumProperty<ShimmerDirection>('direction', direction));\n    properties.add(\n        DiagnosticsProperty<Duration>('period', period, defaultValue: null));\n    properties\n        .add(DiagnosticsProperty<bool>('enabled', enabled, defaultValue: null));\n    properties.add(DiagnosticsProperty<int>('loop', loop, defaultValue: 0));\n  }\n}\n\nclass _ShimmerState extends State<Shimmer> with SingleTickerProviderStateMixin {\n  late AnimationController _controller;\n  int _count = 0;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this, duration: widget.period)\n      ..addStatusListener((AnimationStatus status) {\n        if (status != AnimationStatus.completed) {\n          return;\n        }\n        _count++;\n        if (widget.loop <= 0) {\n          _controller.repeat();\n        } else if (_count < widget.loop) {\n          _controller.forward(from: 0.0);\n        }\n      });\n    if (widget.enabled) {\n      _controller.forward();\n    }\n  }\n\n  @override\n  void didUpdateWidget(Shimmer oldWidget) {\n    if (widget.enabled) {\n      _controller.forward();\n    } else {\n      _controller.stop();\n    }\n    super.didUpdateWidget(oldWidget);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return AnimatedBuilder(\n      animation: _controller,\n      child: widget.child,\n      builder: (BuildContext context, Widget? child) => _Shimmer(\n        direction: widget.direction,\n        gradient: widget.gradient,\n        percent: _controller.value,\n        child: child,\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n}\n\n@immutable\nclass _Shimmer extends SingleChildRenderObjectWidget {\n  final double percent;\n  final ShimmerDirection direction;\n  final Gradient gradient;\n\n  const _Shimmer({\n    super.child,\n    required this.percent,\n    required this.direction,\n    required this.gradient,\n  });\n\n  @override\n  _ShimmerFilter createRenderObject(BuildContext context) {\n    return _ShimmerFilter(percent, direction, gradient);\n  }\n\n  @override\n  void updateRenderObject(BuildContext context, _ShimmerFilter shimmer) {\n    shimmer.percent = percent;\n    shimmer.gradient = gradient;\n    shimmer.direction = direction;\n  }\n}\n\nclass _ShimmerFilter extends RenderProxyBox {\n  ShimmerDirection _direction;\n  Gradient _gradient;\n  double _percent;\n\n  _ShimmerFilter(this._percent, this._direction, this._gradient);\n\n  @override\n  ShaderMaskLayer? get layer => super.layer as ShaderMaskLayer?;\n\n  @override\n  bool get alwaysNeedsCompositing => child != null;\n\n  set percent(double newValue) {\n    if (newValue == _percent) {\n      return;\n    }\n    _percent = newValue;\n    markNeedsPaint();\n  }\n\n  set gradient(Gradient newValue) {\n    if (newValue == _gradient) {\n      return;\n    }\n    _gradient = newValue;\n    markNeedsPaint();\n  }\n\n  set direction(ShimmerDirection newDirection) {\n    if (newDirection == _direction) {\n      return;\n    }\n    _direction = newDirection;\n    markNeedsLayout();\n  }\n\n  @override\n  void paint(PaintingContext context, Offset offset) {\n    if (child != null) {\n      assert(needsCompositing);\n\n      final double width = child!.size.width;\n      final double height = child!.size.height;\n      Rect rect;\n      double dx, dy;\n      if (_direction == ShimmerDirection.rtl) {\n        dx = _offset(width, -width, _percent);\n        dy = 0.0;\n        rect = Rect.fromLTWH(dx - width, dy, 3 * width, height);\n      } else if (_direction == ShimmerDirection.ttb) {\n        dx = 0.0;\n        dy = _offset(-height, height, _percent);\n        rect = Rect.fromLTWH(dx, dy - height, width, 5.5 * height);\n      } else if (_direction == ShimmerDirection.btt) {\n        dx = 0.0;\n        dy = _offset(height, -height, _percent);\n        rect = Rect.fromLTWH(dx, dy - height, width, 5.5 * height);\n      } else {\n        dx = _offset(-width, width, _percent);\n        dy = 0.0;\n        rect = Rect.fromLTWH(dx - width, dy, 4 * width, height);\n      }\n      layer ??= ShaderMaskLayer();\n      layer!\n        ..shader = _gradient.createShader(rect)\n        ..maskRect = offset & size\n        ..blendMode = BlendMode.srcIn;\n      context.pushLayer(layer!, super.paint, offset);\n    } else {\n      layer = null;\n    }\n  }\n\n  double _offset(double start, double end, double percent) {\n    return start + (end - start) * percent;\n  }\n}\n"
    },
    {
      "name": "grid_background.dart",
      "dir": "lib/majestic/ui/grid_background",
      "content": "import 'package:flutter/material.dart';\nimport 'shimmer.dart';\n\nclass GridBackground extends StatelessWidget {\n  final Color gridColor;\n  final Color animationColor;\n  final double gridSpacing;\n  final double lineWidth;\n  final bool shouldAnimate;\n  final Widget? child;\n  final ShimmerDirection shimmerDirection;\n  final Duration duration;\n  final int loop;\n\n  const GridBackground({\n    super.key,\n    this.gridColor = Colors.white30,\n    this.animationColor = Colors.white60,\n    this.gridSpacing = 15.0,\n    this.lineWidth = 0.5,\n    this.child,\n    this.duration = const Duration(milliseconds: 1500),\n    this.shouldAnimate = true,\n    this.shimmerDirection = ShimmerDirection.btt,\n    this.loop = 0,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: [\n        shouldAnimate\n            ? Shimmer.fromColors(\n                baseColor: gridColor,\n                highlightColor: animationColor,\n                direction: shimmerDirection,\n                enabled: true,\n                loop: loop,\n                period: duration,\n                child: CustomPaint(\n                  painter: GridPainter(\n                    gridColor: animationColor,\n                    gridSpacing: gridSpacing,\n                    lineWidth: lineWidth,\n                  ),\n                  child: Container(),\n                ),\n              )\n            : CustomPaint(\n                painter: GridPainter(\n                  gridColor: gridColor,\n                  gridSpacing: gridSpacing,\n                  lineWidth: lineWidth,\n                ),\n                child: Container(),\n              ),\n        child ?? const SizedBox.shrink(),\n      ],\n    );\n  }\n}\n\nclass GridPainter extends CustomPainter {\n  final Color gridColor;\n  final double gridSpacing;\n  final double lineWidth;\n\n  GridPainter({\n    required this.gridColor,\n    required this.gridSpacing,\n    required this.lineWidth,\n  });\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    final paint = Paint()\n      ..color = gridColor\n      ..strokeWidth = lineWidth\n      ..style = PaintingStyle.stroke;\n\n    // Calculate number of lines needed\n    final horizontalLines = (size.height / gridSpacing).ceil() + 1;\n    final verticalLines = (size.width / gridSpacing).ceil() + 1;\n\n    // Offset for animation\n    const offset = 0;\n\n    // Draw horizontal lines\n    for (var i = 0; i < horizontalLines; i++) {\n      final y = (i * gridSpacing + offset) % (size.height + gridSpacing) -\n          gridSpacing;\n      paint.color = gridColor;\n      canvas.drawLine(\n        Offset(0, y),\n        Offset(size.width, y),\n        paint,\n      );\n    }\n\n    // Draw vertical lines\n    for (var i = 0; i < verticalLines; i++) {\n      final x =\n          (i * gridSpacing + offset) % (size.width + gridSpacing) - gridSpacing;\n      paint.color = gridColor;\n      canvas.drawLine(\n        Offset(x, 0),\n        Offset(x, size.height),\n        paint,\n      );\n    }\n  }\n\n  @override\n  bool shouldRepaint(GridPainter oldDelegate) {\n    return false;\n  }\n}\n"
    }
  ]
}