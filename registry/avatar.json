{
  "name": "avatar",
  "label": "Avatar",
  "description": "An image element with a fallback for representing the user.",
  "dependencies": [
    "cached_network_image"
  ],
  "demo": "import 'package:flutter/material.dart';\n\nimport 'majestic/ui/avatar.dart';\n\nclass AvatarDemo extends StatelessWidget {\n  const AvatarDemo({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            Avatar(\n              \"https://picsum.photos/50\",\n              isRound: true,\n              height: 50,\n              width: 50,\n              radius: 2,\n              text: \"Ronak\",\n            ),\n            Text(\"Ronak\"),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
  "files": [
    {
      "name": "avatar.dart",
      "dir": "lib/majestic/ui",
      "content": "library majestic_avatar;\n\nimport 'dart:math';\n\nimport 'package:cached_network_image/cached_network_image.dart';\nimport 'package:flutter/material.dart';\n\nColor _generateRandomColor() {\n  return Color.fromARGB(\n    255,\n    Random().nextInt(256),\n    Random().nextInt(256),\n    Random().nextInt(256),\n  );\n}\n\n/*\nRULES:\n\n[src] can be\n1. NULL - If it is null, then show background text with random color.\n2. Empty - If it is empty, then show background text with random color.\n3. Network URL - Fetch data from network image.\n4. Asset image - Fetch data using Image.asset.\n\n[isRound vs radius]\n1. isRound and radius, either of those two params are required, not both.\n\n[placeholder]\n\n*/\nclass Avatar extends StatefulWidget {\n  final String? src;\n  final double radius;\n  final String? text;\n  final TextStyle? textStyle;\n  final Color? background;\n  final double? height;\n  final double? width;\n  final BoxFit fit;\n  final bool isRound;\n  final bool useOldImageOnUrlChange;\n\n  const Avatar(\n    this.src, {\n    super.key,\n    this.isRound = false,\n    this.radius = 0,\n    this.height,\n    this.width,\n    this.fit = BoxFit.cover,\n    this.useOldImageOnUrlChange = false,\n    this.text,\n    this.textStyle,\n    this.background,\n  });\n\n  @override\n  State<Avatar> createState() => _CachedImageState();\n}\n\nclass _CachedImageState extends State<Avatar> {\n  Color? _color;\n\n  @override\n  void initState() {\n    super.initState();\n    _color = widget.background ?? _generateRandomColor();\n  }\n\n  Widget _baseBackground(String? text) {\n    return Container(\n      decoration: BoxDecoration(\n        shape: widget.isRound ? BoxShape.circle : BoxShape.rectangle,\n        color: _color,\n      ),\n      height: widget.height,\n      width: widget.width,\n      alignment: Alignment.center,\n      child: text != null\n          ? LayoutBuilder(\n              builder: (context, constraints) {\n                double fontSize =\n                    min(constraints.maxWidth, constraints.maxHeight) * 0.5;\n                return Text(\n                  text[0].toUpperCase(),\n                  style: TextStyle(\n                    fontSize: fontSize,\n                    fontWeight: FontWeight.w500,\n                    color: _color!.computeLuminance() > .5\n                        ? Colors.black\n                        : Colors.white,\n                  ),\n                );\n              },\n            )\n          : const SizedBox.shrink(),\n    );\n  }\n\n  Widget _getChild() {\n    if (widget.src == null) {\n      return _baseBackground(widget.text);\n    }\n    return CachedNetworkImage(\n      imageUrl: widget.src!,\n      fit: widget.fit,\n      useOldImageOnUrlChange: widget.useOldImageOnUrlChange,\n      placeholder: (context, url) => _baseBackground(widget.text),\n      errorWidget: (context, url, error) {\n        print(error);\n        return Container(\n          height: widget.height,\n          width: widget.width,\n          color: Colors.black,\n        );\n      },\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      height: widget.height,\n      width: widget.width,\n      child: ClipRRect(\n        borderRadius: widget.isRound\n            ? BorderRadius.circular(300)\n            : BorderRadius.circular(widget.radius),\n        child: _getChild(),\n      ),\n    );\n  }\n}\n"
    }
  ]
}